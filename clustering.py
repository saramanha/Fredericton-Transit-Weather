# -*- coding: utf-8 -*-
"""Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CV1y9PCb9jP_NtbMlesaMIXpmKDQWy76
"""

import pandas as pd

"""**Preparing Data**"""

df = pd.read_csv("Transit_Weather.csv")

grouped_df = df.groupby(['user_id', 'route']).size().reset_index(name='count')
pivoted = grouped_df.pivot_table(index='user_id', columns='route', values='count', fill_value=0)
pivoted.reset_index(inplace=True)

pivoted.head()

df['start_time'] = pd.to_datetime(df['start_time'])

time_grouped = df.groupby(['user_id', pd.cut(df['start_time'].dt.hour, bins=[6, 11, 17, 24], labels=['Counts for Mornings', 'Counts for Mid-day', 'Counts for Evenings'])]).size().reset_index(name='count')

time_pivoted = time_grouped.pivot_table(index=['user_id'], columns='start_time', values='count', fill_value=0)

time_pivoted.reset_index(inplace=True)

time_pivoted

final_Users_Df = pd.merge(pivoted, time_pivoted, on='user_id', how='left')
final_Users_Df

boarding_counts = df.groupby(['user_id', 'boarding_stop']).size().reset_index(name='count')

boarding_counts_pivot = boarding_counts.pivot_table(index='user_id', columns='boarding_stop', values='count', fill_value=0)

boarding_counts_pivot.reset_index(inplace=True)

All_Users_Df = pd.merge(final_Users_Df, boarding_counts_pivot, on='user_id', how='left')

"""**Clustering**"""

from sklearn.cluster import KMeans
from sklearn import metrics
import matplotlib.pyplot as plt

#finding the best random state and cluster number

data_for_clustering = final_Users_Df.drop('user_id', axis=1)


best_score = -1
best_kmeans = None
best_k = None
inertia_values = []

cluster_range = range(2, 11)


for k in cluster_range:  # Trying 10 different random_state values
    kmeans = KMeans(n_clusters=k, random_state=28)
    kmeans.fit(data_for_clustering)
    inertia = kmeans.inertia_

    silhouette_score = metrics.silhouette_score(data_for_clustering, kmeans.labels_)
    inertia_values.append(silhouette_score)

    # Selecting the best clustering based on silhouette score
    if silhouette_score > best_score:
        best_score = silhouette_score
        best_kmeans = kmeans
        best_k = k


print(f"Best k: {best_k}")
print(f"Best silhouette score: {best_score}")
print(f"Corresponding inertia: {best_kmeans.inertia_}")



plt.figure(figsize=(8, 6))
plt.plot(cluster_range, inertia_values, marker='o', linestyle='-')
plt.title('Elbow Method for Optimal Number of Clusters')
plt.xlabel('Number of Clusters')
plt.ylabel('silhouette_score')
plt.show()

kmeans1 = KMeans(n_clusters=8, random_state=28)

kmeans1.fit(data_for_clustering)

cluster_labels = kmeans1.labels_

cluster_Centers = kmeans1.cluster_centers_

cluster_centers_df = pd.DataFrame(cluster_Centers, columns=final_Users_Df.drop('user_id', axis=1).columns)

cluster_centers_df

My_cluster_labels = kmeans1.labels_


cluster_centers_df['Cluster'] = range(len(cluster_centers_df))

final_Users_Df['Cluster'] = My_cluster_labels
All_Users_Df['Cluster'] = My_cluster_labels

All_Users_Df[All_Users_Df['Cluster'] == 0]

from pandas.plotting import parallel_coordinates
import seaborn as sns
import matplotlib.pyplot as plt


# Plot parallel coordinates
plt.figure(figsize=(18, 6))
parallel_coordinates(cluster_centers_df, 'Cluster', colormap='viridis', linewidth=2, alpha=0.7 )

plt.xticks(rotation='vertical')
plt.grid(visible=False)

plt.title('Parallel Coordinates of Clustering Centers')
plt.xlabel('Routes')
plt.ylabel('Average of Transit Sessions')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()

from pandas.plotting import parallel_coordinates
import seaborn as sns
import matplotlib.pyplot as plt


indices_to_remove = [1]
new_cluster_centers_df = cluster_centers_df.iloc[indices_to_remove]


# Plot parallel coordinates
plt.figure(figsize=(18, 6))
parallel_coordinates(new_cluster_centers_df, 'Cluster', colormap='viridis', linewidth=2, alpha=0.7 )

plt.xticks(rotation='vertical')
plt.grid(visible=False)

plt.title('Parallel Coordinates of Clustering Centers')
plt.xlabel('Routes')
plt.ylabel('Average of Transit Sessions')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()

from pandas.plotting import parallel_coordinates
import seaborn as sns
import matplotlib.pyplot as plt


indices_to_remove2 = [0,2,3,6]
new_cluster_centers_df2 = cluster_centers_df.drop(indices_to_remove2)


# Plot parallel coordinates
plt.figure(figsize=(18, 6))
parallel_coordinates(new_cluster_centers_df2, 'Cluster', colormap='viridis', linewidth=2, alpha=0.7 )

plt.xticks(rotation='vertical')
plt.grid(visible=False)

plt.title('Parallel Coordinates of Clustering Centers')
plt.xlabel('Routes')
plt.ylabel('Average of Transit Sessions')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()

cluster_data = {'Cluster': [], 'Number of People': [],'# of Transit Sessions': []}

for my_Cluster_num in range(0,8):

  my_Cluster_df2 = All_Users_Df[All_Users_Df['Cluster']==my_Cluster_num].copy()
  my_Transit_Df2 = pd.merge(df, my_Cluster_df2[['user_id']], on='user_id', how='inner')

  cluster_data['Cluster'].append(my_Cluster_num)
  cluster_data['Number of People'].append(my_Cluster_df2['user_id'].count())
  cluster_data['# of Transit Sessions'].append(my_Transit_Df2['user_id'].count())


mycluster_df = pd.DataFrame(cluster_data)
mycluster_df['Contribution in Transit Data %'] = round(100* (mycluster_df['# of Transit Sessions']/df['user_id'].count()), 2)

final_Users_Df

mycluster_df

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import pandas as pd

data_for_clustering2 = final_Users_Df.drop('user_id', axis=1)

# Perform k-means clustering
kmeans2 = KMeans(n_clusters=8, random_state=28)
kmeans2.fit(data_for_clustering2)

# Getting cluster labels and cluster centers
cluster_labels = kmeans2.labels_
cluster_centers = kmeans2.cluster_centers_

# Visualizing the clusters
plt.figure(figsize=(8, 6))


# Plotting points with cluster assignments
plt.scatter(data_for_clustering2['10N Carlisle'], data_for_clustering2['11S Prospect'], c=cluster_labels, cmap='viridis', edgecolor='k', s=50, alpha=0.15)
# Plotting cluster centers
for i, cluster_center in enumerate(cluster_centers):
    plt.scatter(cluster_center[0], cluster_center[1], c='yellow', marker=f'* ${i}$', s=200)

plt.legend()

plt.title('K-Means Clustering')
plt.xlabel('10N Carlisle')
plt.ylabel('11S Prospect')
plt.grid(True)
plt.show()

"""**Hourly Bus Usage Calculation**"""

import numpy as np
df['date'] = pd.to_datetime(df['date'])

my_Cluster_num = [0,1,2, 3,4,5, 6,7]
my_Route = '11S Prospect'
my_Month_num = [10]


my_Cluster_df = All_Users_Df[All_Users_Df['Cluster'].isin(my_Cluster_num)].copy()
my_Transit_Df = pd.merge(df, my_Cluster_df[['user_id']], on='user_id', how='inner')


my_month_transit_df = my_Transit_Df[my_Transit_Df['date'].dt.month.isin(my_Month_num)]

hourly_data = {'Hour': [], 'Average_Users': []}

for hour in range(6,24):
  selected_df = my_month_transit_df[my_month_transit_df['start_time'].dt.hour == hour]
  #numberOfYears = selected_df.sort_values('date').iloc[-1]['date'].year - selected_df.sort_values('date').iloc[0]['date'].year
  unique_days = selected_df['date'].dt.date.nunique()
  AvgUsersPerHour = 0

  if hour<=18:
    AvgUsersPerHour = selected_df['user_id'].count() / (unique_days*2)
  else:
    AvgUsersPerHour = selected_df['user_id'].count() / (unique_days)

  hourly_data['Hour'].append(hour)
  hourly_data['Average_Users'].append(AvgUsersPerHour)

  #print('At hour: ' + str(hour) + '  The Average number of users on each bus: ' + str(AvgUsersPerHour))
hourly_df = pd.DataFrame(hourly_data)
monthly_mean = hourly_df['Average_Users'].mean()

# Visualize the data using a line graph
plt.figure(figsize=(10, 6))
plt.plot(hourly_df['Hour'], hourly_df['Average_Users'], marker='o', linestyle='-')
plt.title(f'Hourly Bus Usage in Route {my_Route} by Individuals in Clusters 1 and 2')
plt.xlabel('Time of Day (O Clock)')
plt.ylabel('Average Number of Users on Each Bus')
plt.grid(True)
plt.xticks(range(6, 25))

plt.plot(hourly_df['Hour'], np.full(18, monthly_mean), linestyle='-.')

plt.show()